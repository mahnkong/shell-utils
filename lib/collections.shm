#!/usr/bin/env bash

_COLLECTIONS_TEMPDIR=$(mktemp -d)

collections_map_put() {
    local identifier=$1
    local key=$2
    local value=$3

    if ! __check_parameters "Usage: collections_map_put identifier key value" "$value"; then
        return 1
    fi

    collections_map_delete "$identifier" "$key"
    local file=$(__build_filename $identifier map)
    echo "$key:::$value" >> $file
}

collections_map_delete() {
    local identifier=$1
    local key=$2

    if ! __check_parameters "Usage: collections_map_delete identifier key" "$key"; then
        return 1
    fi

    if collections_map_contains "$identifier" "$key"; then
        local file=$(__build_filename $identifier map)
        local tmpfile=$(mktemp -p $_COLLECTIONS_TEMPDIR)
        egrep -v "^$key:::" $file > $tmpfile
        mv $tmpfile $file
    fi
}

collections_map_contains() {
    local identifier=$1
    local key=$2

    if ! __check_parameters "Usage: collections_map_contains identifier key" "$key"; then
        return 1
    fi
 
    local file=$(__build_filename $identifier map)
    if egrep -q "^$key:::" $file > /dev/null 2>&1; then
        return 0
    fi
    return 1
}

collections_map_get() {
    local identifier=$1
    local key=$2

    if ! __check_parameters "Usage: collections_map_get identifier key" "$key"; then
        return 1
    fi
 
    if collections_map_contains "$identifier" "$key"; then
        local file=$(__build_filename $identifier map)
        egrep "^$key:::" $file | sed "s/^$key::://"
        return 0
    fi
    return 1
}

collections_map_keys() {
    local identifier=$1

    if ! __check_parameters "Usage: collections_map_keys identifier" "$identifier"; then
        return 1
    fi
 
    local file=$(__build_filename $identifier map)
    if [ -f $file ]; then
        egrep -o "^.+:::" $file | sed "s/:::$//" > /tmp/out
        egrep -o "^.+:::" $file | sed "s/:::$//"
        return 0
    fi

    return 1
}

collections_map_size() {
    local identifier=$1

    if ! __check_parameters "Usage: collections_map_size identifier" "$identifier"; then
        return 1
    fi
 
    local file=$(__build_filename $identifier map)
    __get_number_of_lines_for_file $file
}

collections_set_size() {
    local identifier=$1

    if ! __check_parameters "Usage: collections_set_size identifier" "$identifier"; then
        return 1
    fi
 
    local file=$(__build_filename $identifier map)
    __get_number_of_lines_for_file $file
}

collections_set_put() {
    local identifier=$1
    local item=$2

    if ! __check_parameters "Usage: collections_set_put identifier item" "$item"; then
        return 1
    fi

    if ! collections_set_contains "$identifier" "$item"; then
        local file=$(__build_filename $identifier set)
        echo $item >> $file
    fi
}

collections_set_delete() {
    local identifier=$1
    local item=$2

    if ! __check_parameters "Usage: collections_set_delete identifier item" "$item"; then
        return 1
    fi

    if collections_set_contains "$identifier" "$item"; then
        local file=$(__build_filename $identifier set)
        local tmpfile=$(mktemp -p $_COLLECTIONS_TEMPDIR)
        egrep -v "^$item$" $file > $tmpfile
        mv $tmpfile $file
    fi

}

collections_set_contains() {
    local identifier=$1
    local item=$2

    if ! __check_parameters "Usage: collections_set_contains identifier item" "$item"; then
        return 1
    fi
    
    local file=$(__build_filename $identifier set)
    if egrep -q "^$item$" $file > /dev/null 2>&1; then
        return 0
    fi
    return 1
}

collections_set_items() {
    local identifier=$1
    if ! __check_parameters "Usage: collections_set_items identifier" "$identifier"; then
        return 1
    fi
 
    local file=$(__build_filename $identifier set)
    if [ -f $file ]; then
        cat $file;
    fi
}

__get_number_of_lines_for_file() {
    local file=$1

    if [ -f $file ]; then
        wc -l $file | cut -d " " -f 1
    else
        echo 0
    fi
    return 0
}

__build_filename() {
    echo "${_COLLECTIONS_TEMPDIR}/${1}.${2}"
}

__check_parameters() {
    local error_string=$1
    local p=$2

    if [ "$p" == "" ]; then
        caller=$(caller 1)
        line=$(echo $caller | cut -d " " -f 1)
        script=$(echo $caller | cut -d " " -f 3)
        echo "Error in $script, line $line - $error_string" >&2
        return 1
    fi
}
 
finish() {
    rm -rf $_COLLECTIONS_TEMPDIR 2> /dev/null
}

trap finish EXIT
